# Converting Python ML Models to WASM for Propeller using `model2wasm`

This guide explains how to convert a trained Python machine-learning model into a **WASM** module using the [`model2wasm`](https://github.com/FriedShrimpBBQ/model2wasm) toolchain, so it can be deployed on a Propeller runtime that supports **WASI**.

## 1. Overview

The `model2wasm` pipeline does:

1. Take a saved Python model (`.pkl`)
2. Use **m2cgen** to generate equivalent **Go** code
3. Adapt the Go code for **TinyGo**
4. Compile to a **WASI-compatible `.wasm`** file
5. Run the WASM module with command-line inputs

Propeller then just needs to host and call this generated WASM module.

## 2. Prerequisites

You’ll need:

* **Python 3** (with `venv` recommended)
* **m2cgen** and model-specific Python dependencies

  * e.g. `scikit-learn` for sklearn models
* **Go**
* **TinyGo**
* Optionally:

  * [`just`](https://github.com/casey/just) for command automation
  * [`wasmer`](https://wasmer.io/) to run/test WASM locally

Clone the repository:

```bash
git clone https://github.com/FriedShrimpBBQ/model2wasm.git
cd model2wasm
```

## 3. Set up the Python environment

Create and activate a virtual environment (recommended):

```bash
python -m venv venv
# Linux/macOS
source venv/bin/activate
# Windows
venv\Scripts\activate
```

Install `m2cgen` and your model dependencies, for example:

```bash
pip install m2cgen scikit-learn
```

> Replace `scikit-learn` with any other library you used to train your model.

## 4. Train and save your model

You can either:

### 4.1 Use your own model

Train your model as usual in Python and save as a pickle:

```python
import joblib

# model = ...  # train your ML model
joblib.dump(model, "mymodel.pkl")
```

### 4.2 Use the demo example

The repo ships a demo generator:

```bash
python demo/generate_model_example.py --filename mymodel
# Produces mymodel.pkl in the repo
```

---

## 5. Generate Go code from the model

From the root of `model2wasm`:

```bash
m2cgen mymodel.pkl --language go > model2tinygo.go
```

This produces Go code that implements your model’s prediction function.

## 6. Produce TinyGo-compatible main file

Use Go to generate a TinyGo-friendly `main.go` from the just-generated file:

```bash
go run model2tinygo.go > main.go
```

At this point you have:

* `model2tinygo.go` – Go model logic (generated by m2cgen)
* `main.go` – Go program entry point suitable for TinyGo→WASM compilation

## 7. Build the WASM file with TinyGo

Compile the Go program targeting **WASI**:

```bash
tinygo build -o mymodel.wasm -target=wasi -wasm-abi=generic main.go
```

Now `mymodel.wasm` is your ML model compiled to WebAssembly.

## 8. (Optional) Use `just` to simplify the pipeline

The repo includes a `justfile` that wraps the full workflow.

List available recipes:

```bash
just -l
```

Typical usage:

```bash
# Linux/macOS
just build-wasm mymodel.pkl mymodel.go mymodel.wasm

# Windows
just --shell powershell.exe --shell-arg -c build-wasm mymodel.pkl mymodel.go mymodel.wasm
```

This performs:

1. Go code generation from `.pkl`
2. TinyGo main creation
3. WASM build

Check `justfile` for exact arguments and details.

## 9. Test the WASM model locally

Use `wasmer` to validate the WASM module on your machine:

```bash
wasmer mymodel.wasm -- 1 2 -2 -1
```

The trailing numbers (`1 2 -2 -1`) are example feature inputs passed to the model. The program prints the prediction, e.g.:

```text
199
```

This confirms the WASM module runs correctly under a WASI environment.

## 10. Running the WASM model on Propeller

Once you have `mymodel.wasm`, deploying to Propeller is conceptually:

1. **Copy the `.wasm` file** into Propeller’s deployment location

   * e.g. a models/ or wasm/ directory
2. **Register the module** with the Propeller runtime

   * e.g. as `"mymodel"` in a configuration file or API call
3. From your app or workflow:

   * Load the module by name
   * Pass feature values as arguments (e.g. `f32` or `i32` arrays)
   * Invoke the exported prediction function
   * Read the returned prediction

The exact steps depend on the Propeller WASM integration, but the requirement is:

* Propeller must support **WASI** modules.
* Your runtime should allow invoking exported functions with primitive arguments and reading back the result.
